import numpy as np
import matlab.engine
import control as co
import matplotlib.pyplot as plt
import cvxpy as cvx
import SLSsyn as Ss

dT = 0.008
s = co.tf([1, 0], [1])


# define other controllers: design sometime ago
A1 = co.c2d(co.tf([1], [1, 6, 5]), dT)
Alp = co.c2d(1.0 / 5 / (0.3 * s + 1) / (0.5 * s + 1) * (0.032 * s + 1) * (0.0021 * s + 1), dT)
Ainf = co.tf(
    [0, 0.000234247581937, -0.001519129809213, 0.004117723048895, -0.005971926120458, 0.004887991561889, -0.002140996863836, 0.000392090600785],
    [1.0, -7.692092610286219, 25.432665781511435, -46.858394653166798, 51.963159172009036, -34.686122493591625, 12.905678916635351, -2.064894113111176], dT)

Ac14 = co.tf(
    [0, 0.000780043976221,  -0.001879759125377, 0.001518988906942, -0.000411374804692, 0],
    [1.0, -2.915259796026691, 2.835076504158775, -0.919776846642308, 0.000000000000039, 0],
    dT)


def plant(Larm=0.4):
    """Nominal Model as defined in Oct02_SISO_model.m

    Return a linear model of the admittance control robot.
    The model has the following form:

    [d  ] = [P11 P12] [fH]
    [fHT]   [P21 P22] [qu]
    [mm ]   [P31 P32]

    y:   position of the end-effector
    fHT: force output, does not have physical meaning, only use to
         form the complementary sensitivity transfer function T.
    mm: effective torque measured,

    fH: force exerted by human,
    qu: control generated by the admittance controller,

    Suppose we have a controller that maps from [mm] to [qu], the
    closed-loop response would be [fH] -> [d, fHT]

    Check org_imgs/Sysdiagram0ax.pdf

    """
    s = co.tf([1, 0], [1])
    R1 = (-s + 55.56) / (s + 55.56) / (0.0437 * s + 1)
    # H = (50 + 5 * s)
    H = 50 * (20 - s) / (20 + s)
    # H = 5
    Se = 2 * np.pi * 73 / (s + 2 * np.pi * 73)
    R2 = 0.475 * s ** 2 / (s / 100 + 1) ** 2 * 35 / (s + 35) * (-s + 66) / (s + 66)

    P = Ss.tf_blocks([[0, R1 * Larm],
                      [0, (R1 * Larm * H + R2)],
                      [Larm * Se, - (R1 * Larm * H + R2) * Se * Larm]])
    return P


def analysis(plant, controller, Mp=1.05, Tr=0.9, controller_name='noname',
             internal_data=None, m=0.5, b=10, k=80):
    """Analysis of closed-loop response.

    Args:
        internal_data: The internal responses {R, M, N, L, H} in that
                       order. Or can be None.
    """
    H = Ss.lft(plant, controller)
    w, q = np.linalg.eig(H.A)
    wmax = w[np.argmax(np.abs(w))]
    if np.abs(wmax) > 1:
        print(" -- Closed-loop system UNSTABLE. w_max={:}".format(wmax))
    else:
        print(" -- Closed-loop system STABLE. w_max={:}".format(wmax))

    # spectral analysis
    w_nyquist = np.pi / dT
    freqs = np.logspace(-2, np.log10(w_nyquist) - 1e-2, 100)
    mag, phase, omega = H.freqresp(freqs)
    # step and impulse response
    T, y_step = co.step_response(H, [0, 10])
    # NOTE1: if T = [0, 10], the algorithm would not compute the
    # impulse response, but the response to a linearly decreasing
    # input from 1 at time 0 to 0 at time 10. To address this issue,
    # input the whole time vector.

    # NOTE2: co.impulse is not identical to matlab impulse. The
    # difference is that co.impulse compute the reponse w.r.t to a
    # input of the form [1, 0, ...], while matlab returns the reponse
    # to [1 / Ts, 0, ...]. Matlab's convention would produce similar
    # impulse response for two corresponding c-time and d-time. co's
    # convention is more theoretical.

    T_step = np.arange(y_step.shape[1]) * dT  # get correct T
    dss = y_step[0, -1]
    # const-jerk input: accelerate to 5 N in 0.3 sec, then deccelerate to 1 in 0.3 sec
    T_forced, F_forced = const_jerk_input(duration=10, accel_duration=0.6, f_max=4, f_ss=1.0, dT=dT)
    T_forced, Y_forced, _ = co.forced_response(H, T_forced, F_forced)

    # step response
    fig, axs = plt.subplots(3, 1)
    axs[0].plot(T_step, y_step[0, :], label='Hd(t)*u(t)')
    axs[0].plot(T_forced, Y_forced[0, :], label='resp to const-jerk')
    axs[0].plot([0, Tr, Tr, 10], [0, 0, 0.98 * dss, 0.98 * dss], '--', c='gray')
    axs[0].plot([0, 10], [Mp * dss, Mp * dss], '--', c='gray', label='dss={:.5f}'.format(dss))
    axs[0].legend(loc=1)  # upper right
    axs[0].set_xlabel('Time(sec)')
    axs[0].set_ylabel('y(m)')

    # impulse response, comparison with an ideal mass/spring/damper
    H_model = co.c2d(co.tf([1], [m, b, k]), dT)
    T_imp = np.arange(0, 10, 0.008)
    _, y_imp = co.impulse_response(H, T_imp)
    _, y_imp_model = co.impulse_response(H_model, T_imp)

    axs[2].plot(T_imp, y_imp[0, :], label='H[n]')
    axs[2].plot(T_imp, y_imp_model[0, :], label='ref-model')
    axs[2].legend()
    axs[2].text(5, 0.0003, 'model(m={:},b={:},k={:})'.format(m, b, k), horizontalalignment='center')

    # frequency responses
    mag_yn = 20 * np.log10(mag[0, 0])
    mag_T = 20 * np.log10(mag[1, 0])
    # bounds on H_yn and H_T
    freqs_bnd_yn = [1e-2, 3.0, 30, 255]
    mag_bnd_yn = [-36, -36, -74, -130]  # db
    freqs_bnd_T = [1e-2, 2.3, 7.3, 25, 61, 140, 357]
    mag_bnd_T = [-4, -4, -18, -14, -21, -34, -67]

    if internal_data is not None:
        T = internal_data['internal responses'][0].shape[0]
    else:
        T = 256
    omegas = np.arange(int(T / 2)) * 2 * np.pi / T / 0.008
    omegas[0] = 1e-2
    wS_inv = np.ones(T) * 100  # infinity
    wS_inv[:int(T / 2)] = np.power(10, np.interp(np.log10(omegas), np.log10(freqs_bnd_yn), mag_bnd_yn) / 20)
    mag_wS = 20 * np.log10(wS_inv)
    axs[1].scatter(omegas[:int(T / 2)], mag_wS[:int(T / 2)], label='1/wN', c='C2')

    axs[1].plot(freqs, mag_yn, label='H_yn(z)', c='C0')
    axs[1].plot(freqs, mag_T, label='T(z)', c='C1')
    axs[1].plot([w_nyquist, w_nyquist], [np.min(mag_yn), np.max(mag_yn)], '--', c='red')
    axs[1].plot(freqs_bnd_yn, mag_bnd_yn, 'x--', c='C0', label='1/wN')
    axs[1].plot(freqs_bnd_T, mag_bnd_T, 'x--', c='C1', label='1/wT')
    axs[1].set_xscale('log')
    axs[1].set_ylabel('Mag(dB)')
    axs[1].set_xlabel('Freq(rad/s)')
    axs[1].legend()

    fig.suptitle('Analysis plots: {:}'.format(controller_name))
    plt.show()

    if internal_data is not None:
        (Rval, Nval, Mval, Lval) = internal_data['internal responses']
        T = Rval.shape[0]
        T_Half = int(T / 2)
        Rdft = np.fft.fft(Rval[:, 0, 0], axis=0)
        plt.vlines(np.arange(T_Half) * 2 * np.pi / T, 0, np.abs(Rdft[:T_Half]))
        plt.title('DFT{{R[0, 0]}} T={:d}'.format(T))
        plt.show()


def const_jerk_input(duration=10, accel_duration=0.6, f_max=4, f_ss=1.0, dT=dT):
    """
    """
    t_arr = np.arange(0, duration, dT)
    f_arr = []
    for t in t_arr:
        if t < accel_duration / 2:
            f_arr.append(t * f_max / (accel_duration / 2))
        elif t < accel_duration:
            f_arr.append(f_max - (t - accel_duration / 2) * (f_max - f_ss) / (accel_duration / 2))
        else:
            f_arr.append(f_ss)
    return t_arr, np.array(f_arr)


def SLS_synthesis_p1(Pssd, T, const_steady=-1, Tr=0.9, regularization=-1, test_signal='step',
                     Mp=1.01, m=0.5, b=10, k=80):
    """Synthesize a controller using SLS.

    Procedure p1

    """
    print("-- Starting SLS_synthesis_p1")
    # parameters
    nu = 1  # 1 dof controller
    ny = 1

    # constants
    nx = Pssd.states
    A, B1, B2, C1, C2, D11, D12, D21, D22 = Ss.get_partitioned_mats(Pssd, nu, ny)

    # variables
    R = []
    M = []
    N = []
    L = []
    for i in range(T):
        R.append(cvx.Variable((nx, nx)))
        N.append(cvx.Variable((nx, ny)))
        M.append(cvx.Variable((nu, nx)))
        L.append(cvx.Variable((nu, ny)))

    # constraints
    # 20c
    constraints = [
        R[0] == 0, M[0] == 0, N[0] == 0,
    ]
    # 20a, 20b
    for n in range(T):
        mult = 1 if n == 0 else 0
        if n == T - 1:
             constraints.extend([
                 - A * R[n] - B2 * M[n] == 0,
                 - A * N[n] - B2 * L[n] == 0,
                 - R[n] * A - N[n] * C2 == 0,
                 - M[n] * A - L[n] * C2 == 0
             ])
        else:
            constraints.extend([
                R[n + 1] - A * R[n] - B2 * M[n] == np.eye(nx) * mult,
                N[n + 1] - A * N[n] - B2 * L[n] == 0,
                R[n + 1] - R[n] * A - N[n] * C2 == np.eye(nx) * mult,
                M[n + 1] - M[n] * A - L[n] * C2 == 0
            ])

    # closed-loop response: (1->2) mapping
    H = cvx.Variable((T, 2))
    for n in range(T):
        if n == 0:
            constraints.append(
                H[n] == cvx.reshape(C1 * R[n] * B1 + D12 * M[n] * B1 + C1 * N[n] * D21 + D12 * L[n] * D21 + D11, (2,)))
        else:
            constraints.append(
                H[n] == cvx.reshape(C1 * R[n] * B1 + D12 * M[n] * B1 + C1 * N[n] * D21 + D12 * L[n] * D21, (2, )))

    h2norm_T = cvx.sum_squares(H[:, 1])
    h1norm_yf = cvx.sum(H[:, 0])

    # constraint in time-domain, if specified.
    if const_steady > 0:
        # input signals
        # step input
        if test_signal == 'step':
            input_signal = np.ones(500)
        elif test_signal == 'const_jerk':
            _, input_signal = const_jerk_input(
                duration=5, accel_duration=0.6, f_max=4, f_ss=1.0)
        else:
            # trivial to satisfy
            input_signal = np.zeros(500)

        horizon = input_signal.shape[0]
        conv_mat = form_convolutional_matrix(input_signal, T)
        upper = np.ones(horizon) * const_steady * Mp
        lower = np.ones(horizon) * (-0.5)
        lower[int(Tr / dT):] = const_steady * 0.98

        # constraints.extend([
        #     conv_mat * H[:, 0] <= upper,
        #     conv_mat * H[:, 0] >= lower
        # ])

        constraints.append(H[:, 0] >= -1e-4)
        constraints.append(h1norm_yf == const_steady)

    # objective: match the impulse response of a given system
    sys_model = co.c2d(co.tf([1], [m, b, k]), dT)
    _, imp_model = co.impulse_response(sys_model, np.arange(T) * dT)
    # NOTE: have to use norm, sum_of_squares does not work. The reason
    # is the magnitude of the objective function must not be too
    # small. The optimizer seems to get confuse and simply stop
    # working.
    objective = 1e6 * cvx.norm(H[11:, 0] - imp_model[0, :T - 11])

    # try some regularization
    if regularization > 0:
        reg = regularization * (cvx.norm1(H))
    else:
        reg = cvx.abs(cvx.Variable())

    # constraint in frequency-domain, if specified
    Hz = Ss.dft_matrix(T) * H
    # form upper bound for noise attenuation
    freqs_bnd_yn = [1e-2, 3.0, 30, 80, 255]  # rad
    mag_bnd_yn = [-10, -10, -40, -74, -130]  # db
    omegas = np.arange(int(T / 2)) * 2 * np.pi / T / dT
    omegas[0] = 1e-2
    wN_inv = np.ones(T) * 100  # infinity
    wN_inv[:int(T / 2)] = np.power(
        10, np.interp(np.log10(omegas), np.log10(freqs_bnd_yn), mag_bnd_yn) / 20)
    constraints.append(cvx.abs(Hz[:, 0]) <= wN_inv)

    freqs_bnd_T = [1e-2, 2.3, 7.3, 25, 61, 140, 357]
    mag_bnd_T = [6, 6, 6, 6, 6, 6, 6]

    wT_inv = np.ones(T) * 100  # infinity
    wT_inv[:int(T / 2)] = np.power(
        10, np.interp(np.log10(omegas), np.log10(freqs_bnd_yn), mag_bnd_yn) / 20)

    # optimize
    obj = cvx.Minimize(objective + reg)
    prob = cvx.Problem(obj, constraints)
    print("-- [SLS_synthesis_p1] Preparing problem with cvxpy!")
    prob.solve(verbose=True, solver=cvx.MOSEK)
    print("-- [SLS_synthesis_p1] optimization status: {:}".format(prob.status))
    print("-- [SLS_synthesis_p1] obj = {:}, reg = {:}".format(objective.value, reg.value))

    if prob.status != "optimal":
        return None, None

    print("-- [SLS_synthesis_p1] Forming controllers!")
    # form controllers (Structure 1, Figure 4b, Wang 2018)
    MB2_value = np.array([(M[n] * B2).value for n in range(T)]).reshape(ny, nu, -1)
    L_value = np.array([L[n].value for n in range(T)]).reshape(ny, ny, -1)

    # since ny=nu=1, we have
    fir_den = [1] + [0 for n in range(T - 1)]
    MB2_tf = co.tf(MB2_value[0, 0], fir_den, dT)
    L_tf = co.tf(L_value[0, 0], fir_den, dT)
    K = co.feedback(1, MB2_tf, sign=-1) * L_tf
    K = Ss.mtf2ss(K, minreal=True)

    # response mapping
    Rval = np.array([R[n].value for n in range(T)]).reshape(-1, nx, nx)
    Nval = np.array([N[n].value for n in range(T)]).reshape(-1, nx, ny)
    Mval = np.array([M[n].value for n in range(T)]).reshape(-1, nu, nx)
    Lval = np.array([L[n].value for n in range(T)]).reshape(-1, nu, ny)
    Hval = np.array(H.value)

    return K, {'internal responses': (Rval, Nval, Mval, Lval),
               'output impulse': Hval, 'L': L_value, 'MB2': MB2_value}


def form_convolutional_matrix(input_signal, T):
    """Find the convolutional matrix for computing convolution.

    Consider a signal x, the output signal y = input_signal * x can be
    computed as the matrix multiplication y = [conv matrix of input_signal] x.

    Let input_signal = u[0],...,u[T-1], the convolutional matrix is
    given by:

    [u[0]                ]
    [u[1], u[0],         ]
    [u[2], u[1], u[0], ..]
    ...
    [u[T-1], ..,     u[0]]
    ...
    [u[N-1], ...         ]
    """
    N = input_signal.shape[0]
    conv_mat = np.zeros((N, T))
    for i in range(T):
        conv_mat[i:, i] = input_signal[:N-i]
    return conv_mat


def main():
    P = plant()
    Pss = Ss.mtf2ss(P, minreal=True)
    Pssd = co.c2d(Pss, dT)

    # synthesize controller
    Asls, internal_data = SLS_synthesis_p1(Pssd, 256, 0.0125, Tr=3.0, regularization=1e-7)
    if Asls is not None:
        analysis(Pssd, Asls, internal_data=internal_data, Tr=1.0, controller_name='SLS')
    analysis(Pssd, A1, Tr=1.0, controller_name='admittance')
    analysis(Pssd, Ac14, Tr=1.0, controller_name='Hinf')

    import IPython
    if IPython.get_ipython() is None:
        IPython.embed()


if __name__ == '__main__':
    main()
