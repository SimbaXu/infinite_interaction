import numpy as np
import matlab.engine
import control as co
import matplotlib.pyplot as plt
import cvxpy as cvx
import SLSsyn as Ss

dT = 0.008
s = co.tf([1, 0], [1])


def plant(Larm=0.4):
    """Nominal Model as defined in Oct02_SISO_model.m

    Return a linear model of the admittance control robot.
    The model has the following form:

    [d  ] = [P11 P12] [fH]
    [fHT]   [P21 P22] [qu]
    [mm ]   [P31 P32]

    y:   position of the end-effector
    fHT: force output, does not have physical meaning, only use to
         form the complementary sensitivity transfer function T.
    mm: effective torque measured,

    fH: force exerted by human,
    qu: control generated by the admittance controller,

    Suppose we have a controller that maps from [mm] to [qu], the
    closed-loop response would be [fH] -> [d, fHT]

    Check org_imgs/Sysdiagram0ax.pdf

    """
    s = co.tf([1, 0], [1])
    R1 = (-s + 55.56) / (s + 55.56) / (0.0437 * s + 1)
    H = (50 + 5 * s)
    Se = 2 * np.pi * 73 / (s + 2 * np.pi * 73)
    R2 = 0.475 * s ** 2 / (s / 100 + 1) ** 2 * 35 / (s + 35) * (-s + 66) / (s + 66)

    P = Ss.tf_blocks([[0, R1 * Larm],
                      [0, (R1 * Larm * H + R2)],
                      [Larm * Se, - (R1 * Larm * H + R2) * Se * Larm]])
    return P


def analysis(plant, controller, Mp=1.05, Tr=0.9):
    """ Analysis of closed-loop response.

    """
    H = Ss.lft(plant, controller)
    w, q = np.linalg.eig(H.A)
    wmax = w[np.argmax(np.abs(w))]
    if np.abs(wmax) > 1:
        print(" -- Closed-loop system UNSTABLE. w_max={:}".format(wmax))
    else:
        print(" -- Closed-loop system STABLE. w_max={:}".format(wmax))

    # spectral analysis
    w_nyquist = np.pi / dT
    freqs = np.logspace(-2, np.log10(w_nyquist) - 1e-2, 100)
    mag, phase, omega = H.freqresp(freqs)
    T, y_step = co.step_response(H, [0, 10])
    T, y_imp = co.impulse_response(H, [0, 10])
    T_step = np.arange(y_step.shape[1]) * dT  # get correct T
    T_imp = np.arange(y_imp.shape[1]) * dT
    dss = y_step[0, -1]

    # step response
    fig, axs = plt.subplots(2, 1)
    axs[0].plot(T_step, y_step[0, :], label='Hd(t)*u(t)')
    axs[0].plot(T_imp, y_imp [0, :], label='Hd(t)*delta(t)')
    axs[0].plot([0, Tr, Tr, 10], [0, 0, 0.98 * dss, 0.98 * dss], '--', c='gray')
    axs[0].plot([0, 10], [Mp * dss, Mp * dss], '--', c='gray', label='dss={:.3f}'.format(dss))
    axs[0].legend()

    # frequency response
    magdb = 20 * np.log10(mag[0, 0])
    axs[1].plot(freqs, magdb, label='H_dn(z)')
    axs[1].plot([w_nyquist, w_nyquist], [np.min(magdb), np.max(magdb)], '--', c='red')
    axs[1].plot([1e-2, 3.0, 30, 255], [-36, -36, -74, -130], 'x--', c='orange', label='1/wN')
    axs[1].set_xscale('log')
    axs[1].set_ylabel('Mag(db)')
    axs[1].set_xlabel('Freq(rad/s)')
    axs[1].legend()

    plt.show()


def SLS_synthesis_p1(Pssd, T, const_steady=-1, Tr=0.9):
    """Synthesize a controller using SLS.

    Procedure p1

    """
    print("-- Starting SLS_synthesis_p1")
    # parameters
    nu = 1  # 1 dof controller
    ny = 1

    # constants
    nx = Pssd.states
    A, B1, B2, C1, C2, D11, D12, D21, D22 = Ss.get_partitioned_mats(Pssd, nu, ny)

    # variables
    R = []
    M = []
    N = []
    L = []
    for i in range(T):
        R.append(cvx.Variable((nx, nx)))
        N.append(cvx.Variable((nx, ny)))
        M.append(cvx.Variable((nu, nx)))
        L.append(cvx.Variable((nu, ny)))

    # constraints
    # 20c
    constraints = [
        R[0] == 0, M[0] == 0, N[0] == 0,
    ]
    # 20a, 20b
    for n in range(T):
        mult = 1 if n == 0 else 0
        if n == T - 1:
             constraints.extend([
                 - A * R[n] - B2 * M[n] == 0,
                 - A * N[n] - B2 * L[n] == 0,
                 - R[n] * A - N[n] * C2 == 0,
                 - M[n] * A - L[n] * C2 == 0
             ])
        else:
            constraints.extend([
                R[n + 1] - A * R[n] - B2 * M[n] == np.eye(nx) * mult,
                N[n + 1] - A * N[n] - B2 * L[n] == 0,
                R[n + 1] - R[n] * A - N[n] * C2 == np.eye(nx) * mult,
                M[n + 1] - M[n] * A - L[n] * C2 == 0
            ])

    # closed-loop response: (1->2) mapping
    H = []
    for n in range(T):
        if n == 0:
            H.append(C1 * R[n] * B1 + D12 * M[n] * B1 + C1 * N[n] * D21 + D12 * L[n] * D21 + D11)
        else:
            H.append(C1 * R[n] * B1 + D12 * M[n] * B1 + C1 * N[n] * D21 + D12 * L[n] * D21)

    H00_conv = []
    for n in range(T):
        if n == 0:
            H00_conv.append(H[n][0])
        else:
            H00_conv.append(H[n][0] + H00_conv[n - 1])

    # constraints on step response
    for n in range(T):
        constraints.append(H00_conv[n] <= 0.615 * 1.01)
        if n > int(Tr / dT):
            constraints.append(H00_conv[n] >= 0.615 * 0.98)

    h2norm = 0  # h2 norm
    h1norm = 0
    for n in range(T):
        if n == 0:
            h2norm += cvx.sum_squares(H[n])
        else:
            h2norm += cvx.sum_squares(H[n])
        h1norm += H[n][0]

    if const_steady > 0:
        constraints.append(h1norm == const_steady)

    # optimize
    obj = cvx.Minimize(h2norm)
    prob = cvx.Problem(obj, constraints)
    print("-- [SLS_synthesis_p1] Preparing problem with cvxpy!")
    prob.solve(verbose=True, solver='MOSEK')
    print("-- [SLS_synthesis_p1] optimization status: {:}".format(prob.status))
    print("-- [SLS_synthesis_p1] h1norm = {:}".format(h1norm.value))

    if prob.status != "optimal":
        return None, None

    print("-- [SLS_synthesis_p1] Forming controllers!")
    # form controllers (Structure 1, Figure 4b, Wang 2018)
    MB2_value = np.array([(M[n] * B2).value for n in range(T)]).reshape(ny, nu, -1)
    L_value = np.array([L[n].value for n in range(T)]).reshape(ny, ny, -1)

    # since ny=nu=1, we have
    fir_den = [1] + [0 for n in range(T - 1)]
    # MB2_tf = mtf2ss(co.tf(MB2_value[0, 0], fir_den, dT), eng, minreal=True)
    # L_tf = mtf2ss(co.tf(L_value[0, 0], fir_den, dT), eng, minreal=True)
    MB2_tf = co.tf(MB2_value[0, 0], fir_den, dT)
    L_tf = co.tf(L_value[0, 0], fir_den, dT)
    K = co.feedback(1, MB2_tf, sign=-1) * L_tf
    K = Ss.mtf2ss(K, minreal=True)
    return K, (R, N, M, L, H)


def main():
    P = plant()
    Pss = Ss.mtf2ss(P, minreal=False)
    Pssd = co.c2d(Pss, dT)

    # controllers to test
    A1 = co.c2d(co.tf([1], [1, 6, 5]), dT)
    Alp = co.c2d(1.0 / 5 / (0.3 * s + 1) / (0.5 * s + 1) * (0.032 * s + 1) * (0.0021 * s + 1), dT)
    Ainf = co.tf(
        [0, 0.000234247581937, -0.001519129809213, 0.004117723048895, -0.005971926120458, 0.004887991561889, -0.002140996863836, 0.000392090600785],
        [1.0, -7.692092610286219, 25.432665781511435, -46.858394653166798, 51.963159172009036, -34.686122493591625, 12.905678916635351, -2.064894113111176], dT)

    Ac14 = co.tf(
        [0, 0.000780043976221,  -0.001879759125377, 0.001518988906942, -0.000411374804692, 0],
        [1.0, -2.915259796026691, 2.835076504158775, -0.919776846642308, 0.000000000000039, 0],
        dT)

    Asls, internal_data = SLS_synthesis_p1(Pssd, 300, 0.615)
    # analysis(Pssd, Asls)

    analysis(Pssd, A1)

    import IPython
    if IPython.get_ipython() is None:
        IPython.embed()


if __name__ == '__main__':
    main()
