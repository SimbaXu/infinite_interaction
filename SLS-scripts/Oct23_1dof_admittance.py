import numpy as np
import matlab.engine
import control as co
import matplotlib.pyplot as plt
import cvxpy as cvx
import SLSsyn as Ss

dT = 0.008
s = co.tf([1, 0], [1])


# define other controllers: design sometime ago
A1 = co.c2d(co.tf([1], [1, 6, 5]), dT)
Alp = co.c2d(1.0 / 5 / (0.3 * s + 1) / (0.5 * s + 1) * (0.032 * s + 1) * (0.0021 * s + 1), dT)
Ainf = co.tf(
    [0, 0.000234247581937, -0.001519129809213, 0.004117723048895, -0.005971926120458, 0.004887991561889, -0.002140996863836, 0.000392090600785],
    [1.0, -7.692092610286219, 25.432665781511435, -46.858394653166798, 51.963159172009036, -34.686122493591625, 12.905678916635351, -2.064894113111176], dT)

Ac14 = co.tf(
    [0, 0.000780043976221,  -0.001879759125377, 0.001518988906942, -0.000411374804692, 0],
    [1.0, -2.915259796026691, 2.835076504158775, -0.919776846642308, 0.000000000000039, 0],
    dT)


def plant(Larm=0.4):
    """Nominal Model as defined in Oct02_SISO_model.m

    Return a linear model of the admittance control robot.
    The model has the following form:

    [d  ] = [P11 P12] [fH]
    [fHT]   [P21 P22] [qu]
    [mm ]   [P31 P32]

    y:   position of the end-effector
    fHT: force output, does not have physical meaning, only use to
         form the complementary sensitivity transfer function T.
    mm: effective torque measured,

    fH: force exerted by human,
    qu: control generated by the admittance controller,

    Suppose we have a controller that maps from [mm] to [qu], the
    closed-loop response would be [fH] -> [d, fHT]

    Check org_imgs/Sysdiagram0ax.pdf

    """
    s = co.tf([1, 0], [1])
    R1 = (-s + 55.56) / (s + 55.56) / (0.0437 * s + 1)
    H = (50 + 5 * s)
    Se = 2 * np.pi * 73 / (s + 2 * np.pi * 73)
    R2 = 0.475 * s ** 2 / (s / 100 + 1) ** 2 * 35 / (s + 35) * (-s + 66) / (s + 66)

    P = Ss.tf_blocks([[0, R1 * Larm],
                      [0, (R1 * Larm * H + R2)],
                      [Larm * Se, - (R1 * Larm * H + R2) * Se * Larm]])
    return P


def analysis(plant, controller, Mp=1.05, Tr=0.9, controller_name='noname',
             internal_data=None):
    """Analysis of closed-loop response.

    Args:
        internal_data: The internal responses {R, M, N, L, H} in that
                       order. Or can be None.
    """
    H = Ss.lft(plant, controller)
    w, q = np.linalg.eig(H.A)
    wmax = w[np.argmax(np.abs(w))]
    if np.abs(wmax) > 1:
        print(" -- Closed-loop system UNSTABLE. w_max={:}".format(wmax))
    else:
        print(" -- Closed-loop system STABLE. w_max={:}".format(wmax))

    # spectral analysis
    w_nyquist = np.pi / dT
    freqs = np.logspace(-2, np.log10(w_nyquist) - 1e-2, 100)
    mag, phase, omega = H.freqresp(freqs)
    T, y_step = co.step_response(H, [0, 10])
    T, y_imp = co.impulse_response(H, [0, 10])
    T_step = np.arange(y_step.shape[1]) * dT  # get correct T
    T_imp = np.arange(y_imp.shape[1]) * dT
    dss = y_step[0, -1]

    # step response
    fig, axs = plt.subplots(2, 1)
    axs[0].plot(T_step, y_step[0, :], label='Hd(t)*u(t)')
    axs[0].plot(T_imp, y_imp [0, :], label='Hd(t)*delta(t)')
    axs[0].plot([0, Tr, Tr, 10], [0, 0, 0.98 * dss, 0.98 * dss], '--', c='gray')
    axs[0].plot([0, 10], [Mp * dss, Mp * dss], '--', c='gray', label='dss={:.5f}'.format(dss))
    axs[0].legend()
    axs[0].set_xlabel('Time(sec)')
    axs[0].set_ylabel('y(m)')

    # frequency responses
    mag_yn = 20 * np.log10(mag[0, 0])
    mag_T = 20 * np.log10(mag[1, 0])
    # bounds on H_yn and H_T
    freqs_bnd_yn = [1e-2, 3.0, 30, 255]
    mag_bnd_yn = [-36, -36, -74, -130]  # db
    freqs_bnd_T = [1e-2, 2.3, 7.3, 25, 61, 140, 357]
    mag_bnd_T = [-4, -4, -18, -14, -21, -34, -67]

    if internal_data is not None:
        T = internal_data[0].shape[0]
    else:
        T = 256
    omegas = np.arange(int(T / 2)) * 2 * np.pi / T / 0.008
    omegas[0] = 1e-2
    wS_inv = np.ones(T) * 100  # infinity
    wS_inv[:int(T / 2)] = np.power(10, np.interp(np.log10(omegas), np.log10(freqs_bnd_yn), mag_bnd_yn) / 20)
    mag_wS = 20 * np.log10(wS_inv)
    axs[1].scatter(omegas[:int(T / 2)], mag_wS[:int(T / 2)], label='1/wN', c='C2')

    axs[1].plot(freqs, mag_yn, label='H_yn(z)', c='C0')
    axs[1].plot(freqs, mag_T, label='T(z)', c='C1')
    axs[1].plot([w_nyquist, w_nyquist], [np.min(mag_yn), np.max(mag_yn)], '--', c='red')
    axs[1].plot(freqs_bnd_yn, mag_bnd_yn, 'x--', c='C0', label='1/wN')
    axs[1].plot(freqs_bnd_T, mag_bnd_T, 'x--', c='C1', label='1/wT')
    axs[1].set_xscale('log')
    axs[1].set_ylabel('Mag(dB)')
    axs[1].set_xlabel('Freq(rad/s)')
    axs[1].legend()

    fig.suptitle('Analysis plots: {:}'.format(controller_name))
    plt.show()

    if internal_data is not None:
        (Rval, Nval, Mval, Lval, Hval) = internal_data
        T = Rval.shape[0]
        T_Half = int(T / 2)
        Rdft = np.fft.fft(Rval[:, 0, 0], axis=0)
        plt.vlines(np.arange(T_Half) * 2 * np.pi / T, 0, np.abs(Rdft[:T_Half]))
        plt.title('DFT{{R[0, 0]}} T={:d}'.format(T))
        plt.show()


def SLS_synthesis_p1(Pssd, T, const_steady=-1, Tr=0.9, regularization=-1):
    """Synthesize a controller using SLS.

    Procedure p1

    """
    print("-- Starting SLS_synthesis_p1")
    # parameters
    nu = 1  # 1 dof controller
    ny = 1

    # constants
    nx = Pssd.states
    A, B1, B2, C1, C2, D11, D12, D21, D22 = Ss.get_partitioned_mats(Pssd, nu, ny)

    # variables
    R = []
    M = []
    N = []
    L = []
    for i in range(T):
        R.append(cvx.Variable((nx, nx)))
        N.append(cvx.Variable((nx, ny)))
        M.append(cvx.Variable((nu, nx)))
        L.append(cvx.Variable((nu, ny)))

    # constraints
    # 20c
    constraints = [
        R[0] == 0, M[0] == 0, N[0] == 0,
    ]
    # 20a, 20b
    for n in range(T):
        mult = 1 if n == 0 else 0
        if n == T - 1:
             constraints.extend([
                 - A * R[n] - B2 * M[n] == 0,
                 - A * N[n] - B2 * L[n] == 0,
                 - R[n] * A - N[n] * C2 == 0,
                 - M[n] * A - L[n] * C2 == 0
             ])
        else:
            constraints.extend([
                R[n + 1] - A * R[n] - B2 * M[n] == np.eye(nx) * mult,
                N[n + 1] - A * N[n] - B2 * L[n] == 0,
                R[n + 1] - R[n] * A - N[n] * C2 == np.eye(nx) * mult,
                M[n + 1] - M[n] * A - L[n] * C2 == 0
            ])
    # closed-loop response: (1->2) mapping
    H = cvx.Variable((T, 2))
    for n in range(T):
        if n == 0:
            constraints.append(
                H[n] == cvx.reshape(C1 * R[n] * B1 + D12 * M[n] * B1 + C1 * N[n] * D21 + D12 * L[n] * D21 + D11, (2,)))
        else:
            constraints.append(
                H[n] == cvx.reshape(C1 * R[n] * B1 + D12 * M[n] * B1 + C1 * N[n] * D21 + D12 * L[n] * D21, (2, )))

    h2norm_T = cvx.sum_squares(H[:, 1])
    h1norm_yf = cvx.sum(H[:, 0])

    # constraint in time-domain, if specified.
    if const_steady > 0:
        upper = np.ones(T) * const_steady * 1.01
        lower = np.ones(T) * (-0.5)
        lower[int(Tr / dT):] = const_steady * 0.98
        conv_mat = np.tril(np.ones((T, T)))
        constraints.extend([
            conv_mat * H[:, 0] <= upper,
            conv_mat * H[:, 0] >= lower
        ])
        constraints.append(h1norm_yf == const_steady)
        # desired impulse response
        imp_desired = np.zeros(T)
        imp_avg = const_steady / 100  # average length
        for i in range(100):
            imp_desired[i] = 2 * imp_avg - (2 * imp_avg / 100) * i
        h2norm_yf = cvx.norm(H[:, 0] - imp_desired)
    else:
        h2norm_yf = cvx.norm(H[:, 0])
    objective = h2norm_yf

    # try some regularization
    if regularization > 0:
        # objective += regularization * (cvx.norm1(M) + cvx.norm1(N) + cvx.norm1(L) + cvx.norm1(R))
        objective += regularization * (cvx.norm1(H))

    # constraint in frequency-domain, if specified
    Hz = Ss.dft_matrix(T) * H

    # form upper bound for noise attenuation
    freqs_bnd_yn = [1e-2, 3.0, 30, 255]  # rad
    mag_bnd_yn = [-36, -36, -74, -130]  # db
    omegas = np.arange(int(T / 2)) * 2 * np.pi / T / dT
    omegas[0] = 1e-2
    wS_inv = np.ones(T) * 100  # infinity
    wS_inv[:int(T / 2)] = np.power(10, np.interp(np.log10(omegas), np.log10(freqs_bnd_yn), mag_bnd_yn) / 20)
    constraints.append(cvx.abs(Hz[:, 0]) <= wS_inv)

    freqs_bnd_T = [1e-2, 2.3, 7.3, 25, 61, 140, 357]
    mag_bnd_T = [-4, -4, -18, -14, -21, -34, -67]

    # optimize
    obj = cvx.Minimize(objective)
    prob = cvx.Problem(obj, constraints)
    print("-- [SLS_synthesis_p1] Preparing problem with cvxpy!")
    prob.solve(verbose=True, solver='MOSEK')
    print("-- [SLS_synthesis_p1] optimization status: {:}".format(prob.status))
    print("-- [SLS_synthesis_p1] h1norm = {:}".format(h1norm_yf.value))

    if prob.status != "optimal":
        return None, None

    print("-- [SLS_synthesis_p1] Forming controllers!")
    # form controllers (Structure 1, Figure 4b, Wang 2018)
    MB2_value = np.array([(M[n] * B2).value for n in range(T)]).reshape(ny, nu, -1)
    L_value = np.array([L[n].value for n in range(T)]).reshape(ny, ny, -1)

    # since ny=nu=1, we have
    fir_den = [1] + [0 for n in range(T - 1)]
    MB2_tf = co.tf(MB2_value[0, 0], fir_den, dT)
    L_tf = co.tf(L_value[0, 0], fir_den, dT)
    K = co.feedback(1, MB2_tf, sign=-1) * L_tf
    K = Ss.mtf2ss(K, minreal=True)

    # response mapping
    Rval = np.array([R[n].value for n in range(T)]).reshape(-1, nx, nx)
    Nval = np.array([N[n].value for n in range(T)]).reshape(-1, nx, ny)
    Mval = np.array([M[n].value for n in range(T)]).reshape(-1, nu, nx)
    Lval = np.array([L[n].value for n in range(T)]).reshape(-1, nu, ny)
    Hval = np.array(H.value)

    return K, (Rval, Nval, Mval, Lval, Hval)


def main():
    P = plant()
    Pss = Ss.mtf2ss(P, minreal=True)
    Pssd = co.c2d(Pss, dT)

    # synthesize controller
    Asls, internal_data = SLS_synthesis_p1(Pssd, 256, 0.0125, Tr=1.0, regularization=1.)
    if Asls is not None:
        analysis(Pssd, Asls, internal_data=internal_data, Tr=1.0, controller_name='SLS')
    analysis(Pssd, A1, Tr=1.0, controller_name='admittance')
    analysis(Pssd, Ac14, Tr=1.0, controller_name='Hinf')

    import IPython
    if IPython.get_ipython() is None:
        IPython.embed()


if __name__ == '__main__':
    main()
