# tf stands for discrete-time transfer function
admittance_control:
  joint_pos_ref: [0, 0.571, 1.0, 0, 0, 0]
  ft_sensor_ref: [19.59, -21.48, 21.71, 0.969593, -1.054332, -0.552897]
  j1:
    tf_f2q_a: [0]
    tf_f2q_b: [1, -0.9995]
  j2:
    tf_f2q_a: [0]
    tf_f2q_b: [1, -0.9995]
  j3:
    # tf_f2q_a: [0]
    # tf_f2q_b: [1, -0.9995]

    # iter 0: classic admittance
    # tf_f2q_a: [0, 3.174e-5, 3.149e-05]
    # tf_f2q_b: [1, -1.9760, 0.9763]

    # -- co1: bad 
    # tf_f2q_a: [0.2667e-3,    0.4610e-3,   -0.5213e-3]
    # tf_f2q_b: [1.0000,   -1.9345,    0.9355]

    # -- co2: good
    # tf_f2q_a: [8.96e-5, 0.21894118e-3, -0.225005648564093e-3]
    # tf_f2q_b: [1.0,  -1.95781306940843, 0.958230747086933]

    # -- co3
    # tf_f2q_a: [0,    0.427229436495119e-3,   -0.552202391072199e-3,    0.132985802426482e-3]
    # tf_f2q_b: [1.0000,   -2.844753082187529,    2.694806599233063,   -0.850015989997929]

    # -- co4
    # tf_f2q_a: [0,   0.496238934530786e-3,  -0.671077692507785e-3,   0.181938016338066e-3]
    # tf_f2q_b: [1.000000000000000,  -2.806717419182626,   2.618724663642117,  -0.811986287629642]

    # -- co5
    # tf_f2q_a: [0,   0.253207742715084e-3,  -0.342451455367363e-3,   0.092866856768151e-3]
    # tf_f2q_b: [1.000000000000000,  -2.806733226547469,   2.618757445810666,  -0.812003256166275]

    # -- co6: new model (considering mapping from q to tau)
    # tf_f2q_a: [0,   0.767754047031220e-4,  -0.556557163821339e-4,  -0.208913668969277e-4]
    # tf_f2q_b: [1.000000000000000,  -2.918173344041162,   2.836863010135406,  -0.918688968373887]

    # -- co7: new model, very small equilibrium load
    # tf_f2q_a: [0,   0.206027344364109e-4, 0.058233897135741e-4, -0.263375641744904e-4]
    # tf_f2q_b: [1.0, -2.942472573403551, 2.885094784932762, -0.942622158006261]

    # -- co8: new model, try to have faster response by reducing constant in cmd->tau mapping (very bad)
    # tf_f2q_a: [0, 0.001935931855360,  -0.002207031475713,   0.000273935309565,0]
    # tf_f2q_b: [1.000000000000000,  -1.990486159780520,   0.990489963174695,   0.0, 0.0]

    # -- co9: 
    # tf_f2q_a: [0,   0.222368723973235e-3,  -0.415077807191947e-3,   0.196906082445961e-3,  -0.004158164982017e-3,   0]
    # tf_f2q_b: [1.0,  -2.965781081741212,   2.931658576963619,  -0.965877440125731,  0.0,0.0]

    # -- co10: S and L are shaped so that the loop gain for frequencies greater than 4 is less than -10db
    # tf_f2q_a: [0,   0.134606575305011e-3,  -0.245252748770937e-3,   0.124272332059469e-3,  -0.013202932124099e-3,                   0]
    # tf_f2q_b: [1.0,  -2.936919033962634,   2.874586029414515,  -0.937665348992668,  0.0,   0.0]

    # -- co11: similar to c10, but push the steady-state value of S, which is the ss error, to half
    # tf_f2q_a: [0, 0.078094187424215e-3, -0.120897049995090e-3, 0.054460236386225e-3, -0.006874940984027e-3,  0.0]
    # tf_f2q_b: [1.0, -2.844706734268471,   2.695268850117542,  -0.850551045627758,   0.0, 0.0]

    # -- co12: bad ss error, but higher bandwidth (4rad/s)
    # tf_f2q_a: [0, 0.093407137631911e-3,  -0.101018694252250e-3, 0.023379294676144e-3, -0.008567770069025e-3, 0.0]
    # tf_f2q_b: [1.0,  -2.805653452540728,   2.620517221444046,  -0.814727944266786,   0.0, 0.0]

    # -- co13: [Oct02_SISO_design] use fH -> (fH - stiffness * d) as a stiffness mapping
    # tf_f2q_a: [0, 0.000466895520008, -0.001097887653450, 0.000865014249499, -0.000228056975400, 0.0]
    # tf_f2q_b: [1.0, -2.891617724121703, 2.788673027066945, -0.897025501674716, 0.000000000000036, 0.0]

    # -- co14: [Oct02_SISO_design] allows slight overshoot in response (zeta = 0.8)
    tf_f2q_a: [0, 0.000780043976221,  -0.001879759125377, 0.001518988906942, -0.000411374804692, 0]
    tf_f2q_b: [1.0, -2.915259796026691, 2.835076504158775, -0.919776846642308, 0.000000000000039, 0]

  j4:
    tf_f2q_a: [0]
    tf_f2q_b: [1, -0.9995]
  j5:
    tf_f2q_a: [0]
    tf_f2q_b: [1, -0.9995]
  j6:
    tf_f2q_a: [0]
    tf_f2q_b: [1, -0.9995]

# controller profiles

# co1 ------------------------------
# the continuous-time tf: 
#        1
# ---------------
# s^2 + 3 s + 5
#
# is transformed to the discrete-time tf with sampling time Ts=8ms:
#   3.174e-05 z + 3.149e-05
#   -----------------------
#   z^2 - 1.976 z + 0.9763
#  
# Sample time: 0.008 seconds
# tf_f2q_a: [0, 3.174e-5, 3.149e-05]
# tf_f2q_b: [1, -1.9760, 0.9763]

# co2 ------------------------------
# continuous-time tf (designed via loop shaping)
# performance: bad, strong vibration
# tf_f2q_a: [0.2667e-3,    0.4610e-3,   -0.5213e-3]
# tf_f2q_b: [1.0000,   -1.9345,    0.9355]

# co3 ---------------------------------------
# designed with loop-shaping
# performance: good
# tf_f2q_a: [8.96e-5, 0.21894118e-3, -0.225005648564093e-3]
# tf_f2q_b: [1.0,  -1.95781306940843, 0.958230747086933]

# co4 ---------------------------------------
# designed with H-infinity
# performance: okay, responsive
# tf_f2q_a: [0,    0.427229436495119e-3,   -0.552202391072199e-3,    0.132985802426482e-3]
# tf_f2q_b: [1.0000,   -2.844753082187529,    2.694806599233063,   -0.850015989997929]

# co5 ---------------------------------------
# designed with H-infinity, accounting for delay
# performance: fast, but slightly fluctuating
# tf_f2q_a: [0,   0.496238934530786e-3,  -0.671077692507785e-3,   0.181938016338066e-3]
# tf_f2q_b: [1.000000000000000,  -2.806717419182626,   2.618724663642117,  -0.811986287629642]

# co6 ----
# designed with H-infinity at LH = 0.7, which is higher than before, accounting for delay
# tf_f2q_a: [0,   0.253207742715084e-3,  -0.342451455367363e-3,   0.092866856768151e-3]
# tf_f2q_b: [1.000000000000000,  -2.806733226547469,   2.618757445810666,  -0.812003256166275]


# the discrete time tf
# 0 / (z - 0.999)
# means a converging joint position, regardless of torque input.
